\documentclass[10pt,cjk,dvipdfm]{beamer}\usepackage{logicthemelive}\usepackage{verbatim}\usepackage{ascmac}\usepackage{bussproofs}\newenvironment{code}{\verbatim}{\endverbatim}\renewcommand{\familydefault}{\sfdefault}\renewcommand{\kanjifamilydefault}{\gtdefault}\setbeamertemplate{navigation symbols}{}\title{\textbf{Coq入門 (2)}}\author{@tmiya\_}\institute{Proof Summit 2011}\date{February 2, 2012}\begin{document}  \maketitle\section{0. はじめに}\frame{  \frametitle{本 Coq 入門コースの目的}  この Coq 入門コースの目的は  \begin{itemize}    \item Coq とは何か (何が出来るか) 知る    \item {\color{blue} Coq の操作方法について慣れる}	\begin{itemize}	  \item Coq のコマンドや文法について知る	  \item {\color{blue} tactic を用いた Coq での証明について慣れる}	\end{itemize}	\item {\color{blue} Coq を用いてのプログラミングについて知る}    \begin{itemize}	  \item 関数型言語的なコーディングに慣れる	  \item {\color{blue} Coq を用いて簡単な定理を証明する}	  \item 仕様を述語論理で記述する	  \item 開発したコードが仕様を満たす事を証明する    \end{itemize}	\item 更なる Coq に関する情報の入手先を知る	\item 証明し易さを意識してプログラミングするようになる  \end{itemize}  です。{\color{blue} 青字部分が今回の目標}で、残りは第３回以降にお話しします。}\section{3.2. 再帰的な型と関数}\frame[containsverbatim]{  \frametitle{自然数 nat について}  自然数 \verb|nat| は下記の様に定義されている。(見やすい様に整形)  \begin{code}Print nat.>> Inductive nat : Set :=  >>   O : nat >> | S : nat -> nat\end{code}\verb|O| (大文字のO) が $0$ を表し、\verb|S| は引数に \verb|nat| を取って、１大きな \verb|nat| を返す関数、と考える。この自然数の定義方法を Peano の自然数という。  \begin{code}Eval compute in (S (S (S O))).>>      = 3>>      : nat\end{code}\verb|S (S (S O))| では人間に不便な為、Coq が $3$ と表示してくれている。}\frame[containsverbatim]{  \frametitle{自然数の加法}  \verb|nat| の加法を定義してみよう。第１引数の \verb|n| についての再帰関数として定義する。  \begin{code}Fixpoint add(n m:nat):nat :=match n with| O => m| S n' => S (add n' m)end.>> add is recursively defined (decreasing on 1st argument)\end{code}再帰関数を定義する際はキーワード \verb|Fixpoint| を用いて定義する。  \begin{code}Eval compute in (add (S (S O)) (S O)).>>      = 3>>      : nat\end{code}上記の計算過程 (call-by-value) を考えてみよ。 }\frame[containsverbatim]{  \frametitle{自然数の比較}  \verb|nat| の値を比較する関数を定義してみよう。\verb|_,_| の部分はどんなパターンがマッチするか、なぜこの定義でOKなのか、考えよう。  \begin{code}Fixpoint eq_nat(n m:nat):bool :=match n,m with| O,O => true| S n', S m' => eq_nat n' m'| _,_ => falseend.Eval compute in (eq_nat 3 3).\end{code}  同様に \verb|le_nat| を定義せよ。\verb|le_nat n m| は $n \leq m$ の真偽値を返す。   再帰関数を定義するとき最初は末尾再帰を考えなくて良い。出来るだけ簡単かつ仕様に忠実に実装する事をまず考える (複雑なものは証明も複雑になりやすいので)。将来必要になってから末尾再帰版と非末尾再帰版が等価である事を証明すれば良い。}\frame[containsverbatim]{  \frametitle{再帰関数の停止性★}  Coq では再帰関数について停止性 (無限ループにならないこと) を保証する必要がある。実はここまで定義した再帰関数は再帰呼び出しの度にどれか一つの引数の構造が必ず小さくなることによって、再帰呼び出しの停止性を保証している。　下記の例は明示的に第１引数 \verb|n| の構造についての再帰と宣言した例 (\verb|{struct n}| は Coq が推論するため省略可)  \begin{code}Coq < Fixpoint add'(n m:nat){struct n} :=Coq < match n withCoq < | O => mCoq < | S n' => S (add' n' m)Coq < end.add' is recursively defined (decreasing on 1st argument)\end{code}  例：\verb|add' 2 3| であれば、add' の第１引数が毎回簡単になっている。  \begin{code}  add' (S (S O)) 3 = S (add' (S O) 3)= S (S (add' O 3)) = S (S 3) = 5.\end{code}}\frame[containsverbatim]{  \frametitle{チューリングマシンの停止性判定★}  「停止性判定が不可能」というのは「チューリングマシンで動く全てのプログラムに対して」停止性を判定することは出来ない (そのようなアルゴリズムがあると矛盾する) ということ。    Coq では停止性を保証したプログラムしか書けない (※) (停止すると判らないプログラムは処理系が受理しない) ため、Coq のプログラムが必ず停止する事は上記と矛盾しない。(つまりチューリングマシンで許される全てのプログラムが Coq で許される訳では無い。)    同様にライスの定理から「『全てのプログラムについて』それが仕様を満たすか判定する方法は無い」ことが言えるが、Coq が証明付きで受理したプログラムにバグが無い (証明結果に反した動作をしない) ことは保証出来る。    ※ Coq で書かれた C コンパイラは存在する。Coq でチューリング完全な言語を記述や検証出来ない訳では無い。}\frame[containsverbatim]{  \frametitle{Coq 文法まとめ}  \begin{code}■再帰関数の定義 : Fixpoint 名前(引数:型):型 := 内容. Fixpoint eq_nat(n m:nat):bool :=match n,m with| O,O => true| S n', S m' => eq_nat n' m'| _,_ => falseend.\end{code}■nat を扱う基本 : n を O と S n' にパターンマッチする。}\frame[containsverbatim]{  \frametitle{課題２：自然数の関数}  \begin{enumerate}    \item 掛け算を行う関数 \verb|mul| を \verb|add| を参考に定義せよ。	\item \verb|mul| を用いて階乗を計算する関数 \verb|fact| を定義せよ。($\mathrm{fact}(n+1) = (n+1) \times \mathrm{fact} n, \;\; \mathrm{fact} 0 = 1$)	\item 引き算を行う関数 \verb|sub| を定義してみよ。但し答えが負になる場合は $0$ を返せば良いものとする。	\item 次の関数 \verb|div3| は何を計算する関数か考えよ。また \verb|Eval| を用いて動作を確認してみよ。  \end{enumerate}  \begin{code}Fixpoint div3(n:nat) :=match n with| S (S (S n')) => S (div3 n')| _ => Oend.\end{code}　注意：通常の言語では引き算を行う関数 \verb|sub| から任意の割り算を行う \verb|div n m| を定義するのは簡単。Coq の場合は再帰関数の停止性を保証するため整礎帰納法を用いる必要があり、今日は説明しない。}\section{3.3. 多相型}\frame[containsverbatim]{  \frametitle{多相型とは}  ３引数の関数 \verb|cond c vt vf| を考える。第１引数 \verb|c:bool| が \verb|true| なら \verb|vt| を、\verb|false| なら \verb|vf| を返す。\verb|vt, vf| の型を任意の \verb|Set| の型 \verb|A| として定義したい。  \begin{code}Coq < Definition cond{A:Set}(c:bool)(vt vf:A) :=Coq < match c withCoq < | true => vtCoq < | false => vfCoq < end.Coq < Eval compute in (cond true 2 3).     = 2 : natCoq < Eval compute in (cond false false true).     = true : bool\end{code}  \verb|{A:Set}| も \verb|cond| の引数だが、呼び出し時に \verb|A| が推測出来るならば省略出来る事を示す。(必要なら明示的に指定可)  \begin{code}Coq < Eval compute in (@cond nat false 2 3).\end{code}}\frame[containsverbatim]{  \frametitle{option型}  手続き型言語では(適切な)値が無いことを示す為に null 値などを多用するが、関数型言語では同様の目的で \verb|option| 型 (HaskellではMaybe型) を用いる。(※但し Coq では値が無い理由の証明を含めて表現可能な \verb|sumor| 型を用いる方が便利な事も多い。)  \begin{code}Coq < Print option.Inductive option (A : Type) : Type :=    Some : A -> option A | None : option A\end{code}  \begin{code}Definition option_map {A B:Type} (f:A->B)(o:option A) :=  match o with    | Some a => Some (f a)    | None => None  end.Coq < Eval compute in (option_map (fun x => x + 1) (Some 1)).\end{code}}\frame[containsverbatim]{  \frametitle{prod型とsum型★}  \verb|prod A B| 型は \verb|A| 型と \verb|B| 型の２つの値を組にしたものである。\verb|prod A B| を \verb|A * B| と略記する。\verb|( x , y , .. , z )| というタプルとしての表記は \verb|(pair .. (pair x y) .. z)| の略記法である。  \begin{code}Coq < Check (2,true,3).(2, true, 3) : nat * bool * nat\end{code}    \verb|prod| の第１成分、第２成分を取得する為の関数 \verb|fst, snd| があるが、実際はパターンマッチで分解する事が多い。    \verb|sum A B| 型は、値が \verb|A| 型あるいは \verb|B| 型の値のどちらかであることを示す型である。下記の様に使う。  \begin{code}Coq < Definition test_sum (s:sum nat bool) :=   Coq < match s withCoq < | inl n => nCoq < | inr true => 1Coq < | inr false => 0Coq < end.\end{code}  \verb|prod, sum| 型については Curry-Howard 対応のところで再度触れる。}\frame[containsverbatim]{  \frametitle{List型}  多相型なデータ構造の例として \verb|List| を調べる。\verb|List| は標準ライブラリに定義されている。ライブラリをインポートすれば各種関数や定義が使用出来る。\verb|::| は \verb|cons| を中置演算子に定義したもの。\verb|Type| は \verb|Set| の更に上の型 (\verb|Check Set.| してみよ) である。  \begin{code}Coq < Require Import List.Coq < Print list.Inductive list (A : Type) : Type :=    nil : list A 　| cons : A -> list A -> list ACoq < Check (1::2::nil).1 :: 2 :: nil : list nat\end{code}  関数型言語では、再代入を避けたり、再帰呼び出しとの相性などの事情から、データ列を扱う際は配列ではなくリストを多用する。}\frame[containsverbatim]{  \frametitle{Listに対する再帰関数}  List に対する再帰関数を定義する場合は、List を \verb|nil| と \verb|x::xs| とにパターンマッチで場合分けすることを考える。  \begin{code}Coq < Fixpoint append{A:Type}(xs ys:list A):=Coq < match xs withCoq < | nil => ysCoq < | x::xs' => x::(append xs' ys)Coq < end.Coq < Eval compute in (append (1::2::nil) (3::4::nil)).Coq < Fixpoint olast{A:Type}(xs:list A):option A :=Coq < match xs withCoq < | nil => NoneCoq < | a::nil => Some aCoq < | _::xs' => olast xs'Coq < end.Coq < Eval compute in (olast (1::2::3::nil)).\end{code}}\frame[containsverbatim]{  \frametitle{課題３：Listへの関数}  \begin{enumerate}    \item リストの長さを与える関数 \verb|len{A:Type}(xs:list A):nat| を定義せよ。\verb|Eval compute in (len (1::2::3::nil)).| などで確認せよ。	\item \verb|list bool| の入力を受け取り、全要素が \verb|true| の時 \verb|true| を返す関数 \verb|all_true(xs:list bool):bool| を定義せよ。但し \verb|nil| に対しては \verb|true| を返すとせよ。	\item リストの先頭要素 \verb|x| があれば \verb|Some x| を、空リストに対しては \verb|None| を返す、関数 \verb|ohead{A:Type}(xs:list A):option A| を定義せよ。	\item 自然数 \verb|s|, \verb|n| に対して \verb|s :: s+1 :: ... :: (s+n-1) :: nil| を返す関数 \verb|nat_list(s n:nat):list nat| を定義せよ。	\item リストを反転する関数 \verb|reverse{A:Type}(xs:list A):list A| を定義せよ。必要なら \verb|append| を使え。  \end{enumerate}}\section{4. 定理と証明}\frame[containsverbatim]{  \frametitle{真理値表を使った証明}  前回、Bool 型についての De Morgan 則を証明した。その際に行った事は下記の様な真理値表の全ケースについて一致する事を確かめることであった。  \begin{center}  \begin{tabular}{c|c|c|c}    \hline    $P$ & $Q$ & $\neg (P \wedge Q)$ & $\neg P \vee \neg Q$ \\    \hline    F & F & T & T \\    F & T & T & T \\    T & F & T & T \\    T & T & F & F \\    \hline  \end{tabular}  \end{center}  Bool, nat 型のような \verb|Inductive| を用いて定義した型については、全ての値を列挙して場合分けする事が可能である。(\verb|nat| については \verb|O| と \verb|S n| に列挙して場合分けしていると考える。)    しかし Coq が採用する「直観論理」という論理体系では、\verb|Prop| に属する「命題の型」については真偽で場合分け出来ない、と考える。(実際、直観論理では上記の２つの命題が等価である事を示せない。)}\frame[containsverbatim]{  \frametitle{排中律について}  排中律というのは「どんな命題 $P$ についても、$P$ か $\neg P$ のどちらかは成り立つ」という(古典)論理の公理である。通常の数学の証明では排中律を自由に使うが、プログラムを書く立場では排中律が役に立たない場合もある。排中律の説明でよく使われる例を示す。    「定理：$a^b$ が有理数となる様な 無理数 $a , b$が存在する」  \begin{enumerate}    \item $a = b = \sqrt{2}$ とする。$a, b$ は無理数であり、$a^b = \sqrt{2}^{\sqrt{2}}$ がもし有理数ならば証明終わり。	\item 上の $a^b$ が無理数の場合は、$a = \sqrt{2}^{\sqrt{2}}, b = \sqrt{2}$ とする。$a , b$ は無理数であり、$a^b = (\sqrt{2}^{\sqrt{2}})^{\sqrt{2}} = \sqrt{2}^{\sqrt{2} \sqrt{2}} = \sqrt{2}^2 = 2$ は有理数。  \end{enumerate}  よって $\sqrt{2}^{\sqrt{2}}$ が、有理数(\verb|P|)か無理数(\verb|~P|)かのどちらかが成り立つならば、$a^b$ が有理数となる様な 無理数 $a , b$が存在する。    ではこの証明は「仕様：$a^b$ が有理数となる様な 無理数 $a , b$を計算する」というプログラム開発の役に立つだろうか？  直観主義論理はこの排中律を認めない立場の論理体系である。}\frame[containsverbatim]{  \frametitle{公理と推論規則に基づく証明}  直観主義論理では真理値表による証明が使えない。そこで定式化として自然推論と呼ばれる、公理と推論規則による証明を用いる。公理は「正しいと認めて良い命題」であり、推論規則は「(幾つかの)正しい命題を組み合わせて正しい命題を導く規則」である。  推論規則の例としていわゆる三段論法の Modus Ponens と呼ばれる規則がある。命題「$A$」が成り立つ、命題「$A$ ならば $B$ である」が成り立つならば、命題「$B$」が成り立つ、というものである。($\Gamma$ = 仮定(公理含む)の集合。「仮定 $\vdash$ 結論」という記法。)  \begin{prooftree}     \AxiomC{$\Gamma \vdash A$} 	\AxiomC{$\Gamma \vdash A \rightarrow B$}	\RightLabel{($\rightarrow$ 除去)} \BinaryInfC{$\Gamma \vdash B$}   \end{prooftree}  上記は(上から下の向きに考えると)$\rightarrow$除去規則となっている。自然演繹ではこのような推論規則を用いて公理から様々な「正しい命題」を構成する。    Coq の証明は逆にこの証明図を下から上へ辿る形で行われる。ゴールに$B$、仮定に\verb|Hab| : $A \rightarrow B$ が存在する時に、\verb|apply Hab.| という tactic を実行するとゴールが $A$ に変化する。ここで仮定あるいは公理に \verb|Ha| : $A$ が存在すれば、\verb|exact Ha.| を実行すると証明が完了する。}\frame[containsverbatim]{  \frametitle{ゴールと仮定が一致する場合}  Coq の証明で必要な tactic を示す。まず証明のゴールと同じものが、仮定の中にある場合は、tactic の \verb|assumption.| を使用すると証明が完了する。\verb|exact H.| あるいは \verb|trivial.| も同じ目的に使用出来る。  \begin{code}... H : A ... ------------------------A\end{code}  仮定の中に無いが既存の定理と一致する場合は \verb|exact 定理名.| とすれば良い。    これは自然演繹の推論規則としては、  \begin{prooftree}   \AxiomC{$A \in \Gamma$}   \RightLabel{(仮定)} \UnaryInfC{$\Gamma \vdash A$}  \end{prooftree}   に相当する。}\section{4.1. $\rightarrow$ を含む証明}\frame[containsverbatim]{  \frametitle{ゴールに$\rightarrow$を含む場合}  ゴールが $A \rightarrow B$ (CUI端末では \verb|A -> B| と表示) の様な形をしている場合は、$A$ を仮定に持って行く為に \verb|intro Ha.| という tactic を用いる。すると仮定に \verb|Ha : A| が追加され、ゴールが \verb|B| となる。    Coq の証明では上記の様にゴールを徐々に簡単な形に変形して進める事が多い。   これは自然演繹の推論規則としては、  \begin{prooftree}   \AxiomC{...}  \UnaryInfC{$\Gamma, A \vdash B$}  \RightLabel{($\rightarrow$ 導入)}   \UnaryInfC{$\Gamma \vdash A \rightarrow B$}  \end{prooftree}   に相当する。    ゴールが $H_1 \rightarrow H_2 \rightarrow \dots \rightarrow H_n \rightarrow B$ の場合は \verb|intros H1 H2 ... Hn.| と同時に複数 intro することも出来る。また \verb|intro.| や \verb|intros.| とすると Coq が自動的に仮定に名前を付けてくれる。    逆の働きをする $\rightarrow$除去規則は、先に述べた Modus Ponens であり、対応する tactic は \verb|apply 仮定名.| である。}\frame[containsverbatim]{  \frametitle{例題：$\rightarrow$ のみを含む命題(1)}  ここまで学んだ tactic だけで証明出来る例題を解いてみよう。値は「値の型の型」\verb|Set| に属していた。命題 \verb|P| は型であり「命題の型」\verb|Prop| に属している。命題 \verb|P| は型であり、 \verb|P| に属する、\verb|P| の証明の実体 \verb|p : P| が存在する。(型階層としては \verb|Set, Prop| は同じレベルで、その上に \verb|Type| が存在する。)  \begin{code}  Section imp_sample.  Variables P Q R : Prop.  Theorem imp_sample : (P -> (Q -> R)) -> (P -> Q) -> P -> R.1 subgoal    ============================   (P -> Q -> R) -> (P -> Q) -> P -> R\end{code}  二重線 \verb|===| の上が仮定、下がゴールである。このゴールを tactic を用いて変形していく。ゴールが $\rightarrow$ を含む場合は \verb|intro(s)| を用いる。}\frame[containsverbatim]{  \frametitle{例題：$\rightarrow$ のみを含む命題(2)}  ゴールの $\rightarrow$ を消す為に \verb|intros| を行う。大体の証明の最初の tactic は \verb|intro(s)| である。  \begin{code}imp_sample < intros pqr pq p.1 subgoal    pqr : P -> Q -> R  pq : P -> Q  p : P  ============================   R\end{code}  仮定の中で \verb|R| を導けそうなものを探すと \verb|pqr| が良さそうである。従って \verb|apply pqr.| を入力する。}\frame[containsverbatim]{  \frametitle{例題：$\rightarrow$ のみを含む命題(3)}  ゴールの $R$ を消す為に \verb|apply pqr.| をを行う。すると \verb|pqr| の \verb|P -> Q ->| の部分から、ゴール \verb|P| と \verb|Q| が生成される。  \begin{code}imp_sample < apply pqr.2 subgoals    pqr : P -> Q -> R  pq : P -> Q  p : P  ============================   Psubgoal 2 is: Q\end{code}  ここでゴール \verb|P| は仮定にそのままあるので \verb|assumption.| を実行する。}\frame[containsverbatim]{  \frametitle{例題：$\rightarrow$ のみを含む命題(4)}  ゴールの $P$ を消す為に \verb|assumption.| を行う。すると 残りのゴール \verb|Q| が証明課題となる。  \begin{code}imp_sample < assumption.1 subgoal    pqr : P -> Q -> R  pq : P -> Q  p : P  ============================   Q\end{code}  ゴール \verb|Q| を導くにはどうすればよいか考えてみよう。}\frame[containsverbatim]{  \frametitle{例題：$\rightarrow$ のみを含む命題(5)}  \begin{code}imp_sample < apply pq.1 subgoal    pqr : P -> Q -> R  pq : P -> Q  p : P  ============================   Pimp_sample < assumption.Proof completed.imp_sample < Qed.\end{code}  証明が完了したら最後に \verb|Qed.| を入力する。}\section{4.2. $\wedge$ を含む証明}\frame[containsverbatim]{  \frametitle{$\wedge$ を含む場合(1)}  仮定が $P \wedge Q$ という形の場合、$P$ と $Q$ という２つの仮定に分解したい。仮定 \verb|pq : P /\ Q| を分解するには \verb|destruct pq as [p q].| という tactic を使う。すると \verb|p : P| と \verb|q : Q| の２つの仮定に分解される。単に \verb|destruct pq.| とした場合は \verb|p,q| ではなく Coq が適当な名前を付ける。    ゴールが $P \wedge Q$ という形をしている場合は、$P$ と $Q$ の両方を示す事が出来れば $P \wedge Q$ を示せる。\verb|split.| という tactic を用いると現在のゴール \verb|P /\ Q| を２つのサブゴール \verb|P|, \verb|Q| に分割する。    例として次の定理を証明する。  \begin{code}Coq < Variable P Q R:Prop.Coq < Theorem and_assoc : (P/\Q)/\R -> P/\(Q/\R).1 subgoal    ============================   (P /\ Q) /\ R -> P /\ Q /\ R\end{code}}\frame[containsverbatim]{  \frametitle{$\wedge$ を含む場合(2)}  まず intro してゴールの $\rightarrow$ を除去し、次いで仮定の $\wedge$ を分解する。  \begin{code}and_assoc < intro pqr. 1 subgoal    pqr : (P /\ Q) /\ R  ============================   P /\ Q /\ Rand_assoc < destruct pqr as [[p q] r].1 subgoal    p : P  q : Q  r : R  ============================   P /\ Q /\ R\end{code}}\frame[containsverbatim]{  \frametitle{$\wedge$ を含む場合(3)}  次いでゴールを分解し、個々の仮定と一致したら assumption を使用する。\verb|;| で tactic を連結可能で、split で生成された２つのゴールの両方に assumption を使用する。  \begin{code}and_assoc < split.2 subgoals  ============================   Psubgoal 2 is: Q /\ Rand_assoc < assumption.1 subgoal  ============================   Q /\ Rand_assoc < split; assumption.Proof completed.and_assoc < Qed.\end{code}}\section{4.3. $\vee$ を含む証明}\frame[containsverbatim]{  \frametitle{$\vee$ を含む場合(1)}  仮定が $P \vee Q$ という形の場合、$P$ が成立する場合と $Q$ が成立する場合との両方について証明をする必要がある。仮定 \verb|pq : P \/ Q| を分解するには \verb+destruct pq as [p|q].+ という tactic を使う。すると仮定に \verb|p : P| が含まれる場合と \verb|q : Q| の場合の２つのサブゴールに分解される。単に \verb|destruct pq.| とした場合は \verb|p,q| ではなく Coq が適当な名前を付ける。    ゴールが $P \vee Q$ という形をしている場合は、$P$ と $Q$ のどちらかを示す事が出来れば $P \vee Q$ を示せる。\verb|left.| あるいは \verb|right.| という tactic を用いて証明出来そうなゴール \verb|P| あるいは \verb|Q| のどちらかを選択する。    例として次の定理を証明する。  \begin{code}Coq < Variable P Q R:Prop.Coq < Theorem or_assoc : (P\/Q)\/R -> P\/(Q\/R).1 subgoal    ============================   (P \/ Q) \/ R -> P \/ Q \/ R\end{code}}\frame[containsverbatim]{  \frametitle{$\vee$ を含む場合(2)}  まず intro してゴールの $\rightarrow$ を除去し、次いで仮定の $\vee$ を分解する。  \begin{code}and_assoc < intro pqr. or_assoc < destruct pqr as [[p|q]|r].3 subgoals    p : P  ============================   P \/ Q \/ Rsubgoal 2 is: P \/ Q \/ Rsubgoal 3 is: P \/ Q \/ R\end{code}}\frame[containsverbatim]{  \frametitle{$\vee$ を含む場合(3)}  ゴールを分解し、個々の仮定と一致したら assumption を使用。  \begin{code}or_assoc < left.3 subgoals  p : P  ============================   Por_assoc < assumption.2 subgoals    q : Q  ============================   P \/ Q \/ Ror_assoc < right; left.2 subgoals    q : Q  ============================   Q\end{code}  以下、同様に証明すればOK。}\section{4.4. $\neg$ を含む証明}\frame[containsverbatim]{  \frametitle{$\neg$ を含む場合(1)}  直観論理では $\neg P$ は $P \rightarrow \mathtt{False}$ にて定義される。$\mathtt{False}$ は  \begin{code}Inductive False : Prop :=\end{code}  で定義される、値が存在しない型である。  ゴールが \verb|~P| の場合は、\verb|intro p.| すると仮定に \verb|p : P| が追加され、ゴールが \verb|False| になる。    仮定に \verb|H : False| が存在する場合は、ゴールが何であれ \verb|elim H.| を実行すると証明が終わる。    仮定が \verb|np : ~P| の形をしている時に、\verb|elim np.| を行うとゴールが何であれ \verb|P| に変わる。    直観論理では二重否定の除去 ($\neg \neg P$ を $P$ にする) が使えない (∵ 排中律と等価なので) といった制約もあり、否定の入った命題の証明は多少面倒であり、またそういう定理も後から使いにくかったりする。}\frame[containsverbatim]{  \frametitle{$\neg$ を含む場合(2)}  例として次の定理を証明する。  \begin{code}Coq < Theorem neg_sample : ~(P /\ ~P).1 subgoal  ============================   ~ (P /\ ~ P)   neg_sample < intro.1 subgoal  H : P /\ ~ P  ============================   False\end{code}}\frame[containsverbatim]{  \frametitle{$\neg$ を含む場合(3)}  \begin{code}neg_sample < destruct H as [p np].1 subgoal  p : P  np : ~ P  ============================   Falseneg_sample < elim np.  p : P  np : ~ P  ============================   P   neg_sample < assumption.Proof completed.\end{code}}\frame[containsverbatim]{  \frametitle{tactic まとめ}  \begin{center}  \begin{tabular}{c|c|c}  記号 & 仮定Hに記号がある & ゴールに記号がある \\  \hline \hline  P $\rightarrow$ Q & \verb|apply H.| & \verb|intro.| \\  P $\wedge$ Q & \verb|destruct H as [p q].| & \verb|split.| \\  P $\vee$ Q & \verb|destruct H as [p|q].| & \verb|left.| か \verb|right.| \\  $\neg$ & \verb|elim H.| & \verb|intro.|  \end{tabular}  \end{center}  ■ゴールと同じものが仮定にある ⇒ \verb|assumption.| あるいは \verb|exact H.|    Curry-Howard 対応を考えると「コンパイラを型チェックを通る関数を書く」=「証明を書く」である。複雑な関数を人間が書き下すのは困難なので、Coq は対話的証明という形でそれを支援する。}\frame[containsverbatim]{  \frametitle{課題４：命題論理の証明}  証明せよ。  \begin{code}Variable A B C D:Prop.Theorem ex4_1 : (A -> C) /\ (B -> D) /\ A /\ B -> C /\ D.Theorem ex4_2 : ~~~A -> ~A.Theorem ex4_3 : (A -> B) -> ~B -> ~A.Theorem ex4_4 : ((((A -> B) -> A) -> A) -> B) -> B.Theorem ex4_5 : ~~(A\/~A).\end{code}}\section{5. Curry-Howard 対応}\frame[containsverbatim]{  \frametitle{Curry-Howard 対応(1)}  先の定理を別のやり方で証明してみよう。定理の名前を少し変えて入力する。  \begin{code}Theorem imp_sample' : (P -> (Q -> R)) -> (P -> Q) -> P -> R.imp_sample' < intros pqr pq p.imp_sample' < Check pq.  pq     : P -> Qimp_sample' < Check (pq p).pq p     : Q\end{code}  命題 \verb|pq| の型は \verb|P -> Q| であることが判る。これは型 \verb|P| の引数を受け取って型 \verb|Q| の値を返す関数である。従って、\verb|pq| に引数 \verb|p| を与えると結果の型は \verb|Q| になる。}\frame[containsverbatim]{  \frametitle{Curry-Howard 対応(2)}  \verb|pqr, pq, p| を使って型 \verb|R| の値を作る方法を考えると下記の様になる。これを \verb|exact| tactic を用いて与えると証明が完了する。  \begin{code}imp_sample' < Check (pqr p (pq p)).pqr p (pq p)     : Rimp_sample' < exact (pqr p (pq p)).Proof completed.\end{code}  これをみて判る様に証明とは、仮定を引数、ゴールを戻り値、とした関数を書くことに他ならない。実際、定理 \verb|imp_sample| を Print してみると判る。  \begin{code}Coq < Print imp_sample.imp_sample = fun (pqr : P -> Q -> R) (pq : P -> Q) (p : P) => pqr p (pq p)     : (P -> Q -> R) -> (P -> Q) -> P -> R\end{code}}\frame[containsverbatim]{  \frametitle{Curry-Howard 対応(3)}  先ほどの例を観た様に証明とプログラムの間には  \begin{center}  \begin{tabular}{c|c}  証明 & プログラム \\  \hline \hline  命題 $P$ & 型 \verb|P| \\ \hline  命題 $P \rightarrow Q$ & 関数 \verb|P -> Q| \\ \hline  { \AxiomC{$\Gamma \vdash P$} 	\AxiomC{$\Gamma \vdash P \rightarrow Q$}	\RightLabel{($\rightarrow$ 除去)} \BinaryInfC{$\Gamma \vdash Q$}	\DisplayProof } & 関数適用 \verb|pq p| \\ \hline  { \AxiomC{$\Gamma, P \vdash Q$}    \RightLabel{($\rightarrow$ 導入)}     \UnaryInfC{$\Gamma \vdash P \rightarrow Q$}	\DisplayProof } & 関数 \verb|pq (p:P):Q| \\ \hline  命題 $P \wedge Q$ & prod 型 \verb|(P,Q)| \\ \hline  命題 $P \vee Q$ & sum 型 $\left\{ \begin{array}{l} \mathtt{inl \; P} \\ \mathtt{inr \; Q} \end{array} \right.$ \\ \hline  証明の正しさの検証 & コンパイラの型チェック    \end{tabular}  \end{center}  という対応がある。これを Curry-Howard 対応という。    Curry-Howard 対応を考えると「コンパイラを型チェックを通る関数を書く」=「証明を書く」である。複雑な関数を人間が書き下すのは困難なので、Coq は対話的証明という形でそれを支援する。}\frame[containsverbatim]{  \frametitle{Curry-Howard 対応(4)}  命題論理の証明の検証であれば、Coq でなく多相型 (ジェネリクス) のある静的型付き言語であれば可能である。例えば Java だと $(P \rightarrow Q \rightarrow R) \rightarrow (P \rightarrow Q) \rightarrow P \rightarrow R$ の証明は  \begin{code}interface Fun<A,B> {  public B apply(A a);}public class P {}public class Q {}public class R {}public class Proof {  public R imp_sample(Fun<P,Fun<Q,R>> pqr, Fun<P,Q> pq, P p) {    return pqr.apply(p).apply(pq.apply(p));  }}\end{code}  のコンパイルが通る事で確認出来る。(Java が得意な人は prod 型、sum 型 をどのように表現すれば良いか考えてみよ。また $\neg$ を Java でどう表現するか？)}\section{6. 述語論理}\frame[containsverbatim]{  \frametitle{述語論理}  述語論理では命題論理に加えて、  \begin{itemize}    \item  「全ての $a:A$ について $P \; a$ ($\forall a:A, P \; a$)」: \verb|forall (a:A), P a|    \item  「ある $a:A$ が存在して $P \; a$ ($\exists a:A, P \; a$)」: \verb|exists (a:A), P a|  \end{itemize}  という量化子を用いた記述が使える。    Coq では述語 \verb|P| とは値 \verb|a:A| に応じて命題 \verb|P a:Prop| を返す関数 \verb|A -> Prop| と考える。  Coq は一階述語論理だけではなく高階述語論理もサポートしているので、「全ての値 $a:A$ 」だけでは無く「全ての述語 $P:A \rightarrow \mathsf{Prop}$ 」「引数として述語を取る様な述語」なども記述出来る。    述語は例えば下記の様に定義出来る。  \begin{code}Coq < Definition iszero(n:nat):Prop :=Coq < match n withCoq < | O => TrueCoq < | _ => FalseCoq < end.iszero is defined\end{code}}\frame[containsverbatim]{\section{6.1. $\forall$ がある場合}  \frametitle{$\forall$ がある場合 (1)}  ゴールに \verb|forall| がある場合は、\verb|intro(s)| を行う。実は \verb|forall x:X| は \verb|x:X -> | と同じである。  \begin{code}Coq < Theorem sample_forall : forall (X:Type)(P Q:X->Prop)(x:X),  P x -> (forall y:X, Q y) -> (P x /\ Q x).   ============================   forall (X : Type) (P Q : X -> Prop) (x : X),   P x -> (forall y : X, Q y) -> P x /\ Q xsample_forall < intros X P Q x px Hqy.  X : Type  P : X -> Prop  Q : X -> Prop  x : X  px : P x  Hqy : forall y : X, Q y  ============================   P x /\ Q x\end{code}}\frame[containsverbatim]{  \frametitle{$\forall$ がある場合 (2)}  仮定に \verb|forall y:X| がある場合は、\verb|y| に任意の \verb|X| 型の変数を代入したものを得る事が出来る。  \begin{code}sample_forall < split.  (* ゴールを P x と Q x とに *)sample_forall < assumption. (* P x は仮定 px そのまま *)1 subgoal    X : Type  P : X -> Prop  Q : X -> Prop  x : X  px : P x  Hqy : forall y : X, Q y  ============================   Q xsample_forall < apply (Hqy x).  (* Hqy の y に x を代入 *)Proof completed.\end{code}}\section{6.2. $\exists$ がある場合}\frame[containsverbatim]{  \frametitle{$\exists$ がある場合 (1)}  \begin{code}Coq < Theorem sample_exists : forall (P Q:nat->Prop),Coq < (forall n, P n) -> (exists n, Q n) ->                      Coq < (exists n, P n /\ Q n).sample_exists < intros P Q Hpn Hqn.1 subgoal    P : nat -> Prop  Q : nat -> Prop  Hpn : forall n : nat, P n  Hqn : exists n : nat, Q n  ============================   exists n : nat, P n /\ Q n\end{code}}\frame[containsverbatim]{  \frametitle{$\exists$ がある場合 (2)}  仮定に \verb|exists| がある場合は、仮定に \verb|destruct| を行う。  \begin{code}sample_exists < intros P Q Hpn Hqn.  P : nat -> Prop  Q : nat -> Prop  Hpn : forall n : nat, P n  Hqn : exists n : nat, Q n  ============================   exists n : nat, P n /\ Q nsample_exists < destruct Hqn as [n' qn'].  P : nat -> Prop  Q : nat -> Prop  Hpn : forall n : nat, P n  n' : nat  qn' : Q n'  ============================   exists n : nat, P n /\ Q n\end{code}}\frame[containsverbatim]{  \frametitle{$\exists$ がある場合 (3)}  ゴールに \verb|exists x:X| がある場合は、具体的な \verb|x:X| を用いて \verb|exists x.| を行う。  \begin{code}sample_exists < destruct Hqn as [n' qn'].  :  Hpn : forall n : nat, P n  n' : nat  qn' : Q n'  ============================   exists n : nat, P n /\ Q nsample_exists < exists n'.  :  Hpn : forall n : nat, P n  n' : nat  qn' : Q n'  ============================   P n' /\ Q n'  (* 以下証明してみよ *)\end{code}}\frame[containsverbatim]{  \frametitle{課題５：述語論理の証明}  証明せよ。  \begin{code}Theorem ex5_1 : forall (A:Set)(P:A->Prop),  (~ exists a, P a) -> (forall a, ~P a).Theorem ex5_2 : forall (A:Set)(P Q:A->Prop),  (exists a, P a \/ Q a) ->   (exists a, P a) \/ (exists a, Q a).Theorem ex5_3 : forall (A:Set)(P Q:A->Prop),  (exists a, P a) \/ (exists a, Q a) ->  (exists a, P a \/ Q a).Theorem ex5_4 : forall (A:Set)(R:A->A->Prop),  (exists x, forall y, R x y) -> (forall y, exists x, R x y).Theorem ex5_5 : forall (A:Set)(R:A->A->Prop),  (forall x y, R x y -> R y x) ->  (forall x y z, R x y -> R y z -> R x z) ->  (forall x, exists y, R x y) -> (forall x, R x x).  \end{code}}\section{6.3. $=$ を含む証明}\frame[containsverbatim]{  \frametitle{$=$ を含む証明 (1)}  最も重要な述語は値が等しい事を示す \verb|eq| (\verb|=| も使用可) である。  \begin{code}Inductive eq (A : Type) (x : A) : A -> Prop :=    refl_equal : x = x\end{code}  Coq では\begin{itemize}  \item 型が等しい (\verb|nat| と \verb|bool| では駄目)  \item コンストラクタが等しい (\verb|nat| でも \verb|O| と \verb|S| $n$ では駄目)  \item コンストラクタ引数が等しい (\verb|S| $m$ と \verb|S| $n$ なら $m=n$ が必要)    \end{itemize}の場合のみ、等号が成り立つ。    ゴールが\begin{code}  ============================   n = n\end{code}   になったときは、\verb|apply (refl_equal n).| としても良いが通常は tactic  の \verb|reflexivity.| を用いる。}\frame[containsverbatim]{  \frametitle{$=$ を含む証明 (2)}  等号を含む簡単な式を証明する。\verb|plus| の定義は \verb|Print plus.| で確認可能。式を簡単にする為には tactic の \verb|simpl.| を使う。  \begin{code}Coq < Theorem plus_0_l : forall n, 0 + n = n.plus_0_l < intro n.  n : nat  ============================   0 + n = nplus_0_l < simpl.  n : nat  ============================   n = nplus_0_l < reflexivity.Proof completed.\end{code}}\section{6.4. 帰納法}\frame[containsverbatim]{  \frametitle{帰納法 (1)}  同様に $\forall n:\mathtt{nat}, n + 0 = n$ を証明出来るだろうか？実は \verb|simpl.| を使ってもうまくいかない。  \begin{code}  ============================   n + 0 = nplus_0_r < simpl.  ============================   n + 0 = n\end{code}  これは \verb|plus n m| の \verb|n| の値で場合分けして再帰している為である。  この定理を証明する為には $n$ に関する帰納法：  \begin{enumerate}    \item $n=0$ の時、$n + 0 = n$ が成り立つ。    \item $n=n'$ の時、$n + 0 = n$ が成り立つならば、$n = \mathtt{S} \; n'$ でも $n + 0 = n$ が成り立つ。  \end{enumerate}を用いる。 }\frame[containsverbatim]{  \frametitle{帰納法 (2)}  \verb|n| に関する帰納法を使用する為には \verb+induction n as [|n'].+ または \verb|induction n.| という tactic を使う。Coq 内部では次の定理 \verb|nat_ind| が呼び出される。(\verb|P| に現在のゴール)  \begin{code}Coq < Check nat_ind.nat_ind : forall P : nat -> Prop, P 0 ->   (forall n : nat, P n -> P (S n)) ->   forall n : nat, P n\end{code}この \verb|nat_ind| は \verb|nat| のコンストラクタ \verb|O : nat| と \verb|S : nat -> nat| の形から自動的に生成される。実は \verb|Inductive| を使って定義した型、例えば \verb|bool| などにも \verb|bool_ind| は存在する。  \begin{code}bool_ind : forall P : bool -> Prop,   P true -> P false ->   forall b : bool, P b\end{code}}\frame[containsverbatim]{  \frametitle{帰納法 (3)}  \verb+induction n as [|n'].+ を使用すると、\verb|n| が \verb|0| と \verb|S n'| の場合の証明課題が生成される。前者は \verb|reflexivity.| で OK (simpl.は自動で実行)。  \begin{code}Coq < Theorem plus_0_r : forall n:nat, n + 0 = n.plus_0_r < induction n as [|n'].2 subgoals  ============================   0 + 0 = 0subgoal 2 is: S n' + 0 = S n'plus_0_r < reflexivity.1 subgoal  n' : nat  IHn' : n' + 0 = n'  ============================   S n' + 0 = S n'\end{code}  }\frame[containsverbatim]{  \frametitle{帰納法 (4)}  \verb|n = S n'| の証明課題では \verb|n = n'| では成立するという仮定 \verb|IHn'| が存在するので、これを使う事を考える。    \verb|S n' + 0 = S n'| を証明するため simpl. を使うと \verb|plus| の定義より \verb|S (n' + 0)= S n'| になる。ここで \verb|IHn'| を使って \verb|n' + 0| を \verb|n'| に書き換えるには \verb|rewrite IHn'.| と rewrite を使う。  \begin{code}  ============================   S n' + 0 = S n'plus_0_r < simpl.  IHn' : n' + 0 = n'  ============================   S (n' + 0) = S n'plus_0_r < rewrite IHn'.  IHn' : n' + 0 = n'  ============================   S n' = S n'\end{code}}\frame[containsverbatim]{  \frametitle{課題６:$m+n=n+m$ の証明}  コマンド \verb|SearchAbout| を使うと定義済みの定理を探す事が出来る。  \begin{code}Coq < SearchAbout plus.plus_n_O: forall n : nat, n = n + 0plus_O_n: forall n : nat, 0 + n = nplus_n_Sm: forall n m : nat, S (n + m) = n + S mplus_Sn_m: forall n m : nat, S n + m = S (n + m)mult_n_Sm: forall n m : nat, n * m + n = n * S m\end{code}  定義済みの定理は仮定と同じ様に \verb|rewrite| で使用出来る。(例えば \verb|rewrite <- plus_n_Sm n' m.| など。\verb|rewrite H.| はゴールの中の \verb|H| の左辺を右辺に書き換える。右辺を左辺に書き換える場合は \verb|rewrite <- H.| )    上記の適切な定理を用いて下記を証明せよ。  \begin{code}Theorem plus_comm : forall m n:nat, m + n = n + m.\end{code}}\frame[containsverbatim]{  \frametitle{帰納法 (5)}  帰納法を使った証明は自然数 \verb|nat| 以外の帰納型、例えば \verb|list A| などにも使用する。下記の定理を証明せよ。  \begin{code}Theorem length_app : forall (A:Type)(l1 l2:list A),  length (l1 ++ l2) = length l1 + length l2.\end{code}  \verb|list| のコンストラクタ \verb|cons| は引数を２つ取るため、\verb+induction l1 as [|a l1'].+ などの様に２つ書く (あるいは \verb|induction l1.|)。}\frame[containsverbatim]{  \frametitle{課題７:リストに関する証明 (1)}  \verb|List| をインポートし、リストの連結 \verb|append| とリストの反転 \verb|reverse| を行う関数を定義する。  \begin{code}Require Import List.Fixpoint append{A:Type}(l1 l2:list A):=match l1 with| nil => l2| a::l1' => a::(append l1' l2)end.Fixpoint reverse{A:Type}(l:list A):=match l with| nil => nil| a::l' => append (reverse l') (a::nil)end.\end{code}  ここで下記の定理を証明したい。  \begin{code}Theorem reverse_reverse : forall (A:Type)(l:list A),  reverse (reverse l) = l.\end{code}}\frame[containsverbatim]{  \frametitle{課題７:リストに関する証明 (2)}  下記補題を証明し、それを用いて \verb|reverse_reverse| を証明せよ。  \begin{code}Lemma append_nil : forall (A:Type)(l:list A),  append l nil = l.Lemma append_assoc : forall (A:Type)(l1 l2 l3:list A),  append (append l1 l2) l3 = append l1 (append l2 l3).Lemma reverse_append : forall (A:Type)(l1 l2:list A),  reverse (append l1 l2) = append (reverse l2) (reverse l1).\end{code}}\section{8. まとめ}\frame[containsverbatim]{  \frametitle{形式手法勉強会 Formal Methods Forum}  Coq に限らず様々な形式手法についての勉強会を(ほぼ)月１回、豆蔵セミナールーム(新宿)にて行っています。基本的には、参加者同士で自分が知っている話題に付いて話すという勉強会です。また Google group メーリングリストでも随時質問可能です。    Coq については、ほぼ毎回、何らかの話題について話をしています。2010年度は前述の \textit{Certified Programming with Dependent Types} を皆で読みました。  まだ余り成果は多く有りませんが、Coq の証明付きの正規表現ライブラリなどを作成しました。    勉強会開催情報やメンバー間の情報交換は Google group (\verb|http://groups.google.co.jp/group/fm-forum|) にて行っています。参加希望の方は登録をお願いします。    参加の際は予め自分のノートパソコンに Coq を導入して参加する事をお勧めします。}\end{document} 