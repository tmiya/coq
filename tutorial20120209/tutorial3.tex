\documentclass[10pt,cjk,dvipdfm]{beamer}\usepackage{logicthemelive}\usepackage{verbatim}\usepackage{ascmac}\usepackage{bussproofs}\newenvironment{code}{\verbatim}{\endverbatim}\renewcommand{\familydefault}{\sfdefault}\renewcommand{\kanjifamilydefault}{\gtdefault}\setbeamertemplate{navigation symbols}{}\title{\textbf{Coq入門 (3)}}\author{@tmiya\_}\institute{Proof Summit 2011}\date{February 9, 2012}\begin{document}  \maketitle\section*{はじめに}\frame[containsverbatim]{  \frametitle{Coq で何を証明するか？}  「関数型言語は手続き型言語より生産性が高い」については (少なくとも参加者の皆様には) 異論は無いと思う。が、「Coq による証明駆動開発が、関数型言語でのテスト駆動開発より生産性が高いか」については一部の Coq 熟練者以外には No ということになるかと思う。    Coq を使って (= 証明の為の工数を費やして) メリットのある開発要素は、  \begin{itemize}  \item 高信頼性が要求されるプログラム (例えば鉄道や原子炉、医療機器などの制御系とか)  \item 繰り返し共用される為、一度だけ大きな工数を払う価値が有る (コンパイラ、GC アルゴリズム、コレクションライブラリ、DSL の正しさ、など)  \item そもそも定理証明系と相性が良い課題 (シリアライザやプロトコル変換の等価性証明)  \end{itemize}  ということになるだろう。近い将来、自動証明技術の発達が進めば定理証明系適用の閾は下がるが、それまでは我々が Coq に習熟する他は無い。}\frame[containsverbatim]{  \frametitle{例：Coq のコレクションライブラリ(1)}  Coq にもコレクションライブラリ (標準, user contribution) が存在し、様々なデータ構造を提供している。コレクションライブラリでは、  \begin{itemize}    \item 対象となるデータ構造 (例 : \texttt{list})    \item そのデータ構造に対して使える関数 (例 : \verb|map|, \verb|filter|, \verb|length|, ...)    \item そのデータ構造や関数の満たす性質 (例 : \verb|in_map|, \verb|map_length|, ...)    \item そのデータ構造に対する便利な tactic (例 : \verb|simpl_list|, \verb|invList|, ...)  \end{itemize}  などが提供される。通常のプログラミング言語同様、将来の保守性を考え、Coq でも標準ライブラリで提供されるものは原則それを使用するのが望ましい。}\frame[containsverbatim]{  \frametitle{例：Coq のコレクションライブラリ(2)}  例えばこのような定理はリストに関する性質として必要になると思われるだろう。  \begin{code}Require Import List.Goal forall (A:Type)(xs ys:list A), length (xs++ys) = length xs + length ys.Proof.induction xs.  intro ys. simpl. reflexivity.  intro ys. simpl. erewrite IHxs. reflexivity.Qed.\end{code}この定理はライブラリに \verb|app_length| として予め用意されている。List ライブラリの関数や定理を再実装するのは勉強目的以外では必要無いが、自分で作成したコレクションの連結に関して同様の定理はおそらく必要になるだろう。}\section*{命題論理復習}\frame[containsverbatim]{  \frametitle{命題論理式をどう読むか}  命題論理式も式である以上、木構造になっているが、命題論理記号の優先度に慣れるまでは、式の纏まりの単位が判りにくいかもしれない。一方で、例えばゴールに対する tactic である \texttt{intro, split, left/right} などは、ゴールの式の木の頂点の演算子に対して選択するものであるから、式を正しく把握出来る必要がある。\begin{code}(A -> C) /\ (B -> D) /\ A /\ B -> C /\ D------------------------------    ------(A -> C) /\ (B -> D) /\ A /\ B    C    D--------    ------------------    -    - A    C      B -> D     A /\ B -    -     --------    ------                       B    D     A    B             -    -     -    -\end{code} }\section*{命題論理復習}\frame[containsverbatim]{  \frametitle{問題}\begin{code}Section ExProp.Variable A B C D P Q R S:Prop.Goal (P -> Q) -> (Q -> R) -> P -> R.Goal ~False.Goal P -> ~~P.Goal (P -> Q) -> ~Q -> ~P.Goal P /\ (Q /\ R) -> (P /\ Q) /\ R.Goal P /\ (Q \/ R) -> (P /\ Q) \/ (P /\ R).Goal P -> ~P -> Q.Goal (A \/ B -> C) -> (A -> C)/\(B -> C).Goal (A -> (B -> C)) /\ (A -> B) -> (A -> C).Goal (~A /\ ~B) -> ~(A \/ (~A /\ B)).Goal (A -> ~A) -> ~A.Goal (~(A /\ A) -> (~A \/ ~A)).Goal (A -> B) -> (A -> ~B) -> A -> C.End ExProp.\end{code} }\section{6. 述語論理}\frame[containsverbatim]{  \frametitle{述語論理}  述語論理では命題論理に加えて、  \begin{itemize}    \item  「全ての $a:A$ について $P \; a$ ($\forall a:A, P \; a$)」: \verb|forall (a:A), P a|    \item  「ある $a:A$ が存在して $P \; a$ ($\exists a:A, P \; a$)」: \verb|exists (a:A), P a|  \end{itemize}  という量化子を用いた記述が使える。    Coq では述語 \verb|P| とは値 \verb|a:A| に応じて命題 \verb|P a:Prop| を返す関数 \verb|A -> Prop| と考える。  Coq は一階述語論理だけではなく高階述語論理もサポートしているので、「全ての値 $a:A$ 」だけでは無く「全ての述語 $P:A \rightarrow \mathsf{Prop}$ 」「引数として述語を取る様な述語」なども記述出来る。    述語は例えば下記の様に定義出来る。  \begin{code}Coq < Definition iszero(n:nat):Prop :=Coq < match n withCoq < | O => TrueCoq < | _ => FalseCoq < end.iszero is defined\end{code}}\frame[containsverbatim]{\section{6.1. $\forall$ がある場合}  \frametitle{$\forall$ がある場合 (1)}  ゴールに \verb|forall| がある場合は、\verb|intro(s)| を行う。実は \verb|forall x:X| は \verb|x:X -> | と同じである。  \begin{code}Coq < Theorem sample_forall : forall (X:Type)(P Q:X->Prop)(x:X),  P x -> (forall y:X, Q y) -> (P x /\ Q x).   ============================   forall (X : Type) (P Q : X -> Prop) (x : X),   P x -> (forall y : X, Q y) -> P x /\ Q xsample_forall < intros X P Q x px Hqy.  X : Type  P : X -> Prop  Q : X -> Prop  x : X  px : P x  Hqy : forall y : X, Q y  ============================   P x /\ Q x\end{code}}\frame[containsverbatim]{  \frametitle{$\forall$ がある場合 (2)}  仮定に \verb|forall y:X| がある場合は、\verb|y| に任意の \verb|X| 型の変数を代入したものを得る事が出来る。  \begin{code}sample_forall < split.  (* ゴールを P x と Q x とに *)sample_forall < assumption. (* P x は仮定 px そのまま *)1 subgoal    X : Type  P : X -> Prop  Q : X -> Prop  x : X  px : P x  Hqy : forall y : X, Q y  ============================   Q xsample_forall < apply (Hqy x).  (* Hqy の y に x を代入 *)Proof completed.\end{code}}\section{6.2. $\exists$ がある場合}\frame[containsverbatim]{  \frametitle{$\exists$ がある場合 (1)}  \begin{code}Coq < Theorem sample_exists : forall (P Q:nat->Prop),Coq < (forall n, P n) -> (exists n, Q n) ->                      Coq < (exists n, P n /\ Q n).sample_exists < intros P Q Hpn Hqn.1 subgoal    P : nat -> Prop  Q : nat -> Prop  Hpn : forall n : nat, P n  Hqn : exists n : nat, Q n  ============================   exists n : nat, P n /\ Q n\end{code}}\frame[containsverbatim]{  \frametitle{$\exists$ がある場合 (2)}  仮定に \verb|exists| がある場合は、仮定に \verb|destruct| を行う。  \begin{code}sample_exists < intros P Q Hpn Hqn.  P : nat -> Prop  Q : nat -> Prop  Hpn : forall n : nat, P n  Hqn : exists n : nat, Q n  ============================   exists n : nat, P n /\ Q nsample_exists < destruct Hqn as [n' qn'].  P : nat -> Prop  Q : nat -> Prop  Hpn : forall n : nat, P n  n' : nat  qn' : Q n'  ============================   exists n : nat, P n /\ Q n\end{code}}\frame[containsverbatim]{  \frametitle{$\exists$ がある場合 (3)}  ゴールに \verb|exists x:X| がある場合は、具体的な \verb|x:X| を用いて \verb|exists x.| を行う。  \begin{code}sample_exists < destruct Hqn as [n' qn'].  :  Hpn : forall n : nat, P n  n' : nat  qn' : Q n'  ============================   exists n : nat, P n /\ Q nsample_exists < exists n'.  :  Hpn : forall n : nat, P n  n' : nat  qn' : Q n'  ============================   P n' /\ Q n'  (* 以下証明してみよ *)\end{code}}\frame[containsverbatim]{  \frametitle{課題５：述語論理の証明}  証明せよ。  \begin{code}Theorem ex5_1 : forall (A:Set)(P:A->Prop),  (~ exists a, P a) -> (forall a, ~P a).Theorem ex5_2 : forall (A:Set)(P Q:A->Prop),  (exists a, P a \/ Q a) ->   (exists a, P a) \/ (exists a, Q a).Theorem ex5_3 : forall (A:Set)(P Q:A->Prop),  (exists a, P a) \/ (exists a, Q a) ->  (exists a, P a \/ Q a).Theorem ex5_4 : forall (A:Set)(R:A->A->Prop),  (exists x, forall y, R x y) -> (forall y, exists x, R x y).Theorem ex5_5 : forall (A:Set)(R:A->A->Prop),  (forall x y, R x y -> R y x) ->  (forall x y z, R x y -> R y z -> R x z) ->  (forall x, exists y, R x y) -> (forall x, R x x).  \end{code}}\section{6.3. $=$ を含む証明}\frame[containsverbatim]{  \frametitle{$=$ を含む証明 (1)}  最も重要な述語は値が等しい事を示す \verb|eq| (\verb|=| も使用可) である。  \begin{code}Inductive eq (A : Type) (x : A) : A -> Prop :=    refl_equal : x = x\end{code}  Coq では\begin{itemize}  \item 型が等しい (\verb|nat| と \verb|bool| では駄目)  \item コンストラクタが等しい (\verb|nat| でも \verb|O| と \verb|S| $n$ では駄目)  \item コンストラクタ引数が等しい (\verb|S| $m$ と \verb|S| $n$ なら $m=n$ が必要)    \end{itemize}の場合のみ、等号が成り立つ。    ゴールが\begin{code}  ============================   n = n\end{code}   になったときは、\verb|apply (refl_equal n).| としても良いが通常は tactic の \verb|reflexivity.| を用いる。}\frame[containsverbatim]{  \frametitle{$=$ を含む証明 (2)}  等号を含む簡単な式を証明する。\verb|plus| の定義は \verb|Print plus.| で確認可能。式を簡単にする為には tactic の \verb|simpl.| を使う。  \begin{code}Coq < Theorem plus_0_l : forall n, 0 + n = n.plus_0_l < intro n.  n : nat  ============================   0 + n = nplus_0_l < simpl.  n : nat  ============================   n = nplus_0_l < reflexivity.Proof completed.\end{code}}\section{6.4. 帰納法}\frame[containsverbatim]{  \frametitle{帰納法 (1)}  同様に $\forall n:\mathtt{nat}, n + 0 = n$ を証明出来るだろうか？実は \verb|simpl.| を使ってもうまくいかない。  \begin{code}  ============================   n + 0 = nplus_0_r < simpl.  ============================   n + 0 = n\end{code}  これは \verb|plus n m| の \verb|n| の値で場合分けして再帰している為である。  この定理を証明する為には $n$ に関する帰納法：  \begin{enumerate}    \item $n=0$ の時、$n + 0 = n$ が成り立つ。    \item $n=n'$ の時、$n + 0 = n$ が成り立つならば、$n = \mathtt{S} \; n'$ でも $n + 0 = n$ が成り立つ。  \end{enumerate}を用いる。 }\frame[containsverbatim]{  \frametitle{帰納法 (2)}  \verb|n| に関する帰納法を使用する為には \verb+induction n as [|n'].+ または \verb|induction n.| という tactic を使う。Coq 内部では次の定理 \verb|nat_ind| が呼び出される。(\verb|P| に現在のゴール)  \begin{code}Coq < Check nat_ind.nat_ind : forall P : nat -> Prop, P 0 ->   (forall n : nat, P n -> P (S n)) ->   forall n : nat, P n\end{code}この \verb|nat_ind| は \verb|nat| のコンストラクタ \verb|O : nat| と \verb|S : nat -> nat| の形から自動的に生成される。実は \verb|Inductive| を使って定義した型、例えば \verb|bool| などにも \verb|bool_ind| は存在する。  \begin{code}bool_ind : forall P : bool -> Prop,   P true -> P false ->   forall b : bool, P b\end{code}}\frame[containsverbatim]{  \frametitle{帰納法 (3)}  \verb+induction n as [|n'].+ を使用すると、\verb|n| が \verb|0| と \verb|S n'| の場合の証明課題が生成される。前者は \verb|reflexivity.| で OK (simpl.は自動で実行)。  \begin{code}Coq < Theorem plus_0_r : forall n:nat, n + 0 = n.plus_0_r < induction n as [|n'].2 subgoals  ============================   0 + 0 = 0subgoal 2 is: S n' + 0 = S n'plus_0_r < reflexivity.1 subgoal  n' : nat  IHn' : n' + 0 = n'  ============================   S n' + 0 = S n'\end{code}  }\frame[containsverbatim]{  \frametitle{帰納法 (4)}  \verb|n = S n'| の証明課題では \verb|n = n'| では成立するという仮定 \verb|IHn'| が存在するので、これを使う事を考える。    \verb|S n' + 0 = S n'| を証明するため simpl. を使うと \verb|plus| の定義より \verb|S (n' + 0)= S n'| になる。ここで \verb|IHn'| を使って \verb|n' + 0| を \verb|n'| に書き換えるには \verb|rewrite IHn'.| と rewrite を使う。  \begin{code}  ============================   S n' + 0 = S n'plus_0_r < simpl.  IHn' : n' + 0 = n'  ============================   S (n' + 0) = S n'plus_0_r < rewrite IHn'.  IHn' : n' + 0 = n'  ============================   S n' = S n'\end{code}}\frame[containsverbatim]{  \frametitle{課題６:$m+n=n+m$ の証明}  コマンド \verb|SearchAbout| を使うと定義済みの定理を探す事が出来る。  \begin{code}Coq < SearchAbout plus.plus_n_O: forall n : nat, n = n + 0plus_O_n: forall n : nat, 0 + n = nplus_n_Sm: forall n m : nat, S (n + m) = n + S mplus_Sn_m: forall n m : nat, S n + m = S (n + m)mult_n_Sm: forall n m : nat, n * m + n = n * S m\end{code}  定義済みの定理は仮定と同じ様に \verb|rewrite| で使用出来る。(例えば \verb|rewrite <- plus_n_Sm n' m.| など。\verb|rewrite H.| はゴールの中の \verb|H| の左辺を右辺に書き換える。右辺を左辺に書き換える場合は \verb|rewrite <- H.| )    上記の適切な定理を用いて下記を証明せよ。  \begin{code}Theorem plus_comm : forall m n:nat, m + n = n + m.\end{code}}\frame[containsverbatim]{  \frametitle{帰納法 (5)}  帰納法を使った証明は自然数 \verb|nat| 以外の帰納型、例えば \verb|list A| などにも使用する。下記の定理を証明せよ。  \begin{code}Theorem length_app : forall (A:Type)(l1 l2:list A),  length (l1 ++ l2) = length l1 + length l2.\end{code}  \verb|list| のコンストラクタ \verb|cons| は引数を２つ取るため、\verb+induction l1 as [|a l1'].+ などの様に２つ書く (あるいは \verb|induction l1.|)。}\frame[containsverbatim]{  \frametitle{課題７:リストに関する証明 (1)}  \verb|List| をインポートし、リストの連結 \verb|append| とリストの反転 \verb|reverse| を行う関数を定義する。  \begin{code}Require Import List.Fixpoint append{A:Type}(l1 l2:list A):=match l1 with| nil => l2| a::l1' => a::(append l1' l2)end.Fixpoint reverse{A:Type}(l:list A):=match l with| nil => nil| a::l' => append (reverse l') (a::nil)end.\end{code}  ここで下記の定理を証明したい。  \begin{code}Theorem reverse_reverse : forall (A:Type)(l:list A),  reverse (reverse l) = l.\end{code}}\frame[containsverbatim]{  \frametitle{課題７:リストに関する証明 (2)}  下記補題を証明し、それを用いて \verb|reverse_reverse| を証明せよ。  \begin{code}Lemma append_nil : forall (A:Type)(l:list A),  append l nil = l.Lemma append_assoc : forall (A:Type)(l1 l2 l3:list A),  append (append l1 l2) l3 = append l1 (append l2 l3).Lemma reverse_append : forall (A:Type)(l1 l2:list A),  reverse (append l1 l2) = append (reverse l2) (reverse l1).\end{code}}\section{6.5 inversion}\frame[containsverbatim]{  \frametitle{inversion (1)}\verb|induction| の使用が難しい場合は、\verb|inversion| tactic が便利。\begin{code}Inductive even : nat -> Prop :=| even_O : even 0| even_SS : forall n, even n -> even (S (S n)).Theorem even_SS_inv : forall n, even (S (S n)) -> even n.Proof.intros n H. inversion H.n : natH : even (S (S n))n0 : nat      (* H を成立させる前提として *)H1 : even n   (* n0, H1, H0 が生成された *)H0 : n0 = n______________________________________(1/1)even n\end{code}仮定 \verb|H| を成立させるケースが複数あれば、証明課題が複数生成される。}\frame[containsverbatim]{  \frametitle{課題：\texttt{inversion} の練習１}  証明せよ。  \begin{code}Inductive odd : nat -> Prop :=| odd_1 : odd 1| odd_SS : forall n, odd n -> odd (S (S n)).Theorem even_not_odd : forall n, even n -> ~odd n.\end{code}時間があれば下記も証明せよ。 (\verb|inversion| を使うとは限らない。前の定理を後の証明で使うと良い。あるいは次の課題をやっても良い。 )\begin{code}Theorem even_odd : forall n, even n -> odd (S n).Theorem odd_even : forall n, odd n -> even (S n).Theorem even_or_odd : forall n, even n \/ odd n.Theorem odd_odd_even : forall m n,   odd m -> odd n -> even (m + n).\end{code}}\frame[containsverbatim]{  \frametitle{課題：\texttt{inversion} の練習２}  証明せよ。（全てに \verb|inversion| が必要とは限らない。）  \begin{code}Section List_inversion.Require Import List.Variable A:Type.Theorem app_inv_l : forall l l1 l2:list A,  l ++ l1 = l ++ l2 -> l1 = l2.Check app_nil_r.Check app_cons_not_nil.Lemma app_cons_assoc : forall (a:A)(l1 l2:list A),  l1 ++ a::l2 = (l1 ++ a::nil) ++ l2.Lemma app_snoc_inv : forall (a:A)(l1 l2:list A),  l1 ++ a::nil = l2 ++ a::nil -> l1 = l2.Theorem app_inv_r : forall (l l1 l2:list A),  l1 ++ l = l2 ++ l -> l1 = l2.End List_inversion.Check app_inv_head.\end{code}\verb|Section| スコープの外で \verb|A| はどのように扱われているか見よ。}\section{7. 仕様をどう記述するか？}\frame[containsverbatim]{  \frametitle{型 = 仕様、という立場}  静的型付け関数型言語では、型それ自体が関数の仕様という考え方がある。Coq においては、  \begin{itemize}    \item 依存型を用いることで、長さ $n$ の vector なども型として表現出来る。    \item Coq では引数に証明を用いたり、返り値に証明付きの値を用いるなどで、事前条件や事後条件を関数の型として表現出来る。	\item 仕様と実装の分離に関しては	\begin{center}\begin{tabular}{c|c}	  \hline	  仕様 & 実装 \\	  \hline \hline	  値や関数の型 & 具体的な値や関数 \\ \hline	  公理 & 具体的な証明 \\ \hline	  Record宣言, Module Type, Class & Record値, Module, Instance \\ \hline	\end{tabular}\end{center}	となる。(Class/Instance は次回解説予定)  \end{itemize}関数の型で明らかではない仕様については、別に定理の形で関数の性質を証明すれば良い。}\frame[containsverbatim]{  \frametitle{定義 = 仕様、という立場}  計算方法を記述する必要のある手続き型言語と異なり、関数型言語では「関数の仕様通りコードを書けばそれが実装になる」という長所がある。    例えばリストの \texttt{filter} 関数であれば、  \begin{code}Fixpoint filter (l:list A) : list A :=match l with| nil => nil| x :: l => if f x then x::(filter l) else filter lend.\end{code}が、関数の仕様そのままである、と考えることも出来る。関数の定義で明らかではない仕様については、別に定理の形で関数の性質を証明すれば良い。{　}課題：\texttt{In} 関数の実装 (\texttt{Coq.Lists.List} 参照) を調べ、関数の仕様について考えてみよ。}\frame[containsverbatim]{  \frametitle{帰納的定義}  例えば偶数を表す述語を定義するとしよう。Coq の場合、  \begin{code}Definition even1(n:nat):Prop := exists m, 2*m = n.Definition even2(n:nat):Prop := mod2 n = 0.\end{code}の用に内包的定義を使って記述することも可能である。  しかし実際は下記の様に帰納的な定義を用いた方が、証明が不要/簡潔になり望ましい。  \begin{code}Inductive even:nat -> Prop :=| even_O : even 0| even_SS : forall n, even n -> even (S (S n)).\end{code}上記の様に定義することで、induction, inversion などの tactic が利用可能である。帰納的 (inductive) な定義は\begin{itemize} \item 再帰を含まない基底となるケースの規則 \item 再帰的な定義によって基底ケースから遠いケースを定義する規則\end{itemize}の生成規則の閉包 (基底ケース自体、あるいはそれに再帰的なケースを繰り返したもの、で構成される集合) を与える。また帰納的定義は定義を満たす条件を「場合分け」したものと言える。}\frame[containsverbatim]{  \frametitle{決定可能な述語}  前に Coq では「一般には」排中律 ($P \vee \neg P$) は使えないと述べた。しかし、命題の中には成立するか否か決定可能 (decidable) なものがある。    例えば２つの \texttt{nat} が等しいか等しく無いか (\verb|{n=m}+{~(n=m)}|) は決定可能と証明されている。  \begin{code}> Check eq_nat_dec.eq_nat_dec     : forall n m : nat, {n = m} + {n <> m}  \end{code}  このような定理があれば \verb|destruct (eq_nat_dec x 3).| のように、$x = 3$ と $x \neq 3$ とを場合分けすることが出来る。    述語を定義する場合は、戻り値が \text{bool} の関数を定義するよりは、\verb|{P x} + {~P x}| の形の戻り値を返すか、あるいは戻り値が \text{Prop} で、別途 \verb|xxx_dec| という名前で\verb|forall x:X, {P x} + {~P x}| の形の定理を証明するのが良い習慣である。}\frame[containsverbatim]{  \frametitle{宿題：プログラミング課題}  次の問題： 4種類のアルファベット "A,C,G,T" から成るn文字の文字列のうち、"AAG"という並びが含まれる文字列を全て列挙するプログラムを書きなさい。ただし、nは3以上の整数とし、文字列内に同じアルファベットが出現しても構わないものとし、出力順序は問わないものとします。について、\begin{enumerate}  \item 知っているプログラミング言語 (Coq か関数型言語、駄目ならばどの言語でも)  で上記問題を解いて下さい。  \begin{itemize}    \item 但し、\textbf{正規表現ライブラリは使わないこと}が条件。    \item 出来る範囲で、ループではなく再帰を使ったコードを目指して下さい。    \item 単機能の小さな関数を組み合わせてプログラムを作って下さい。    \end{itemize}  \item 上記の小さな関数について、仕様を考えてみて下さい。自然言語の仕様でも構いませんが、出来れば Coq で関数の仕様を示す命題を書き下してみて下さい。\end{enumerate}Coq チュートリアルの第４回の後半で、上記問題 (の一部？) を取り上げる予定です。}\frame[containsverbatim]{  \frametitle{形式手法勉強会 Formal Methods Forum}  Coq に限らず様々な形式手法についての勉強会を(ほぼ)月１回、豆蔵セミナールーム(新宿)にて行っています。基本的には、参加者同士で自分が知っている話題に付いて話すという勉強会です。また Google group メーリングリストでも随時質問可能です。    Coq については、ほぼ毎回、何らかの話題について話をしています。2010年度は前述の \textit{Certified Programming with Dependent Types} を皆で読みました。  まだ余り成果は多く有りませんが、Coq の証明付きの正規表現ライブラリなどを作成しました。    勉強会開催情報やメンバー間の情報交換は Google group (\verb|http://groups.google.co.jp/group/fm-forum|) にて行っています。参加希望の方は登録をお願いします。    参加の際は予め自分のノートパソコンに Coq を導入して参加する事をお勧めします。}\end{document}